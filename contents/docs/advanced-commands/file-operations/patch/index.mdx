---
title: "patch Command"
date: "2025-01-12"
description: "Apply changes to files based on patch files generated by diff."
videoId: ""
---

### Overview

The `patch` command is a powerful Unix utility used to apply changes to files based on patch files, typically generated by the `diff` command. It automates the process of updating files by reading the differences and modifying the target files accordingly. This makes `patch` indispensable for tasks such as updating source code, applying bug fixes, merging changes from different versions, and collaborating in software development projects. By streamlining the application of changes, `patch` enhances productivity and ensures consistency across file versions.

---

### Basic Usage

```bash
patch [options] [originalfile [patchfile]]
```

- **originalfile**: The file to which the patch will be applied. If omitted, `patch` reads from standard input.
- **patchfile**: The file containing the patch (differences) to apply. If omitted, `patch` expects the patch data from standard input.
- **options**: Flags that modify the behavior of the `patch` command.

**Example**:
```bash
patch < changes.patch
```
- Applies the changes described in `changes.patch` to the corresponding original files.

```bash
patch original.txt changes.patch
```
- Applies the patch to `original.txt` using `changes.patch`.

---

### Common Options

1. **`-p<num>` (Strip Prefix)**  
   ```bash
   patch -p1 < changes.patch
   ```
   - Strips the specified number of leading components from file paths in the patch file. This is useful when the patch was created with directory prefixes.

2. **`-R` (Reverse Patch)**  
   ```bash
   patch -R < changes.patch
   ```
   - Reverses the patch, effectively undoing the changes. Useful for reverting applied patches.

3. **`-i <patchfile>` (Specify Patch File)**  
   ```bash
   patch -i changes.patch
   ```
   - Specifies the patch file to read from instead of standard input.

4. **`-o <outputfile>` (Specify Output File)**  
   ```bash
   patch -o newfile.txt < changes.patch
   ```
   - Writes the patched content to `newfile.txt` instead of modifying the original file in place.

5. **`-b` (Backup Original Files)**  
   ```bash
   patch -b < changes.patch
   ```
   - Creates backup copies of original files before applying the patch, typically appending a tilde (`~`) to the filename.

6. **`--dry-run` (Simulate Patch)**  
   ```bash
   patch --dry-run < changes.patch
   ```
   - Simulates applying the patch without making any actual changes. Useful for testing patches.

7. **`--forward` (Apply Only Forward Patches)**  
   ```bash
   patch --forward < changes.patch
   ```
   - Applies only patches that make changes (ignores reverse patches).

8. **`--reject-file=<file>` (Specify Reject File)**  
   ```bash
   patch --reject-file=rejects.txt < changes.patch
   ```
   - Specifies a file to write rejected hunks (parts of the patch that couldn't be applied).

9. **`-F<num>` (Fuzz Factor)**  
   ```bash
   patch -F3 < changes.patch
   ```
   - Allows a specified number of lines to be mismatched when applying the patch, making it more flexible with minor differences.

10. **`--help`**  
    ```bash
    patch --help
    ```
    - Displays help information and exits.

---

### Examples

1. **Apply a Patch to a Single File**  
   ```bash
   patch original.txt < update.patch
   ```
   - Applies the changes from `update.patch` to `original.txt`, updating it accordingly.

2. **Apply a Patch with Directory Prefix Stripping**  
   ```bash
   patch -p1 < project_changes.patch
   ```
   - Strips the first directory component from file paths in `project_changes.patch` before applying the patch.

3. **Create Backup Copies Before Applying Patch**  
   ```bash
   patch -b < changes.patch
   ```
   - Applies the patch while creating backup copies of the original files, such as `original.txt~`.

4. **Reverse a Previously Applied Patch**  
   ```bash
   patch -R < changes.patch
   ```
   - Undoes the changes made by `changes.patch`, restoring the original files.

5. **Simulate Applying a Patch Without Making Changes**  
   ```bash
   patch --dry-run < changes.patch
   ```
   - Checks if the patch can be applied cleanly without actually modifying any files.

6. **Apply a Patch and Specify Output File**  
   ```bash
   patch -o updated.txt < changes.patch
   ```
   - Writes the patched content to `updated.txt`, leaving the original file unchanged.

7. **Apply a Patch and Handle Rejected Hunks**  
   ```bash
   patch --reject-file=rejects.txt < changes.patch
   ```
   - Applies the patch and writes any hunks that couldn't be applied to `rejects.txt`.

8. **Use a Fuzz Factor to Allow Minor Differences**  
   ```bash
   patch -F2 < changes.patch
   ```
   - Applies the patch even if there are up to two lines of difference, accommodating minor discrepancies.

9. **Apply a Patch to Multiple Files Recursively**  
   ```bash
   patch -p1 -R -i changes.patch
   ```
   - Recursively applies the patch to multiple files, reversing the changes if needed.

10. **Combine `patch` with `diff` for Seamless Updates**  
    ```bash
    diff -u original.txt modified.txt > changes.patch
    patch original.txt < changes.patch
    ```
    - Generates a unified diff between `original.txt` and `modified.txt` and then applies the patch to update `original.txt`.

---

### Tips and Best Practices

- **Always Backup Before Patching**: Before applying patches, especially to critical files, ensure you have backups to prevent data loss in case the patch doesn't apply correctly.
  ```bash
  cp original.txt original_backup.txt
  patch < changes.patch
  ```

- **Use Unified Diff Format**: When generating patch files with `diff`, use the unified format (`-u`) for better readability and compatibility with `patch`.
  ```bash
  diff -u original.txt modified.txt > changes.patch
  ```

- **Test Patches with `--dry-run`**: Before making actual changes, use the `--dry-run` option to verify that the patch will apply cleanly.
  ```bash
  patch --dry-run < changes.patch
  ```

- **Handle Rejected Hunks**: After applying a patch, check the reject file (e.g., `rejects.txt`) for any hunks that couldn't be applied and address them manually.
  ```bash
  cat rejects.txt
  ```

- **Understand Patch Context**: Ensure that the context lines in your patch file match the target files. Mismatched contexts can cause patches to fail or apply incorrectly.

- **Use `-p` Option Appropriately**: The `-p` option controls how many leading directories to strip from file paths in the patch. Adjust this based on how the patch was generated to ensure correct file targeting.
  ```bash
  patch -p0 < changes.patch  # No stripping
  patch -p1 < changes.patch  # Strip one leading directory
  ```

- **Apply Patches from Within the Correct Directory**: Navigate to the appropriate directory before applying a patch to ensure that file paths align correctly.
  ```bash
  cd /path/to/project
  patch -p1 < ../changes.patch
  ```

- **Use `patch` with Version Control Systems**: Integrate `patch` with tools like Git for managing and applying changes across different branches or repositories.
  ```bash
  git diff > changes.patch
  git apply changes.patch
  ```

- **Automate Patching in Scripts**: Incorporate `patch` commands into shell scripts for automated deployments, updates, or backups, ensuring consistency and reducing manual effort.
  ```bash
  #!/bin/bash
  patch -p1 < updates.patch
  ```

- **Leverage Colorized Output for Clarity**: Some versions of `patch` support colorized output to enhance readability. Check your version's documentation for support and usage.

- **Understand Exit Codes**: `patch` returns specific exit codes based on the outcome, which can be utilized in scripts for error handling.
  - `0`: No differences.
  - `1`: Differences were found and patches were applied.
  - `2`: Some hunks failed to apply.
  ```bash
  patch < changes.patch
  echo $?
  ```

- **Combine with `grep` for Targeted Patching**: Use `grep` to filter specific changes within a patch file before applying, allowing for more controlled updates.
  ```bash
  grep -E "^@@|^\+" changes.patch | patch < changes.patch
  ```

- **Use `patch` with Binary Files Carefully**: While `patch` is primarily for text files, it can handle binary diffs with specific options. However, it's generally better to use specialized tools for binary data.
  ```bash
  patch --binary < binary_changes.patch
  ```

- **Maintain Consistent Line Endings**: Ensure that the original and target files use consistent line endings (e.g., LF vs. CRLF) to prevent patching issues, especially when working across different operating systems.

- **Review Patch Files Before Applying**: Examine the contents of a patch file to understand the changes it will make, ensuring that they align with your intentions.
  ```bash
  cat changes.patch
  ```

- **Handle Large Patches Efficiently**: For extensive patch files, consider breaking them into smaller chunks or using tools like `split` to manage the application process more effectively.

- **Secure Patch Files**: Protect patch files from unauthorized modifications, especially if they contain critical updates or sensitive changes, to maintain system integrity.

- **Stay Informed About `patch` Updates**: Regularly consult the `patch` manual (`man patch`) and stay updated with the latest versions to utilize new features and improvements.
  ```bash
  man patch
  ```

- **Combine with `tar` for Patching Archives**: Use `tar` in conjunction with `patch` to apply changes to archived collections of files, facilitating bulk updates.
  ```bash
  tar -xvf project.tar.gz
  cd project
  patch -p1 < ../changes.patch
  tar -cvf updated_project.tar.gz *
  ```

- **Use `patch` for Collaborative Development**: Share patch files among team members to distribute changes without requiring direct access to the original source files.
  ```bash
  git format-patch -1 HEAD
  patch -p1 < 0001-commit-message.patch
  ```

- **Handle Conflicts Gracefully**: When a patch doesn't apply cleanly, resolve conflicts manually by editing the affected files and then continue the patching process.
  ```bash
  patch < changes.patch
  # If there are rejects, edit the files and mark as resolved
  patch -R < changes.patch  # To reverse if needed
  ```

- **Understand Patch File Formats**: Familiarize yourself with different patch file formats (unified, context, ed script) to generate and apply patches effectively based on your needs.
  ```bash
  diff -u file1.txt file2.txt > changes.patch
  ```

- **Leverage Graphical Tools for Patching**: Utilize graphical front-ends or integrated development environments (IDEs) that support patching to simplify the process for users who prefer GUI interactions.

- **Monitor Patch Application Progress**: For large patches, keep track of the application progress to ensure that all changes are applied correctly and to identify any issues promptly.